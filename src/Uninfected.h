/*
These cars are the victims in our
attack; they honestly follow the 
- congestion avoidance protocol
in hopes of minimizing their trip times. They share the
congestion measurements in their databases, which are either
generated by themselves or heard from other cars, without
any malicious alteration. 
- Considering that botsâ€™ advertisements
can overwhelm legitimate congestion information (both in
terms of number and freshness of measurements), uninfected
cars will â€œhonestlyâ€� spread the malicious advertisements
originating from botnet members. This will speed up the
effect of our attack. Examples of this behavior will be given
in the next sections, together with experimental results that
show higher percentages of botnet members can overwhelm
legitimate information faster and more effectively.
---------------------------------------------------------------
A. Message Types and Information Exchange
Two types of messages are implemented in our congestion avoidance simulator: 

1) Congestion Request Messages: When a car approaches
the end of a road and can choose from two or more routes, it
will need congestion measurements from other cars in order
to make the choice that will minimize its remaining trip time.
Hence, it broadcasts a congestion request message to all nearby
cars in its communication range to obtain this information. The
content of this message is a list of roads of interest; these are
the roads that form the candidate paths to destination. The car
will choose the path based on the responses it gets.

2) Congestion Response Messages: A congestion response
message is sent only when a congestion request is received and
there are related entries in the congestion information database
of the receiving car, ensuring that no superfluous information
is transmitted. The response includes congestion information
about the roads of interest available at the receiver.

3. These are in addition to the Basic Safety Messages (BSM) that are regularly 
sent to nearby vehicles
----------------------------------------------------------------

B. Congestion Information Database

1) Creating and Storing Congestion Information: In order
to store and exchange congestion measurements, vehicles make
use of congestion info structs. Each struct consists of the
following fields:

a. Creator ID: The unique ID of the vehicle that created this
measurement.
b. Edge ID: The unique ID of the one-way road that this
measurement belongs to.
c. Average Speed: Average of the speed readings from all the
cars on the same road with the car that crates this measurement.
d. Timestamp: Time of the measurementâ€™s creation to ensure
the freshness of measurements and prioritize most recent ones.

2) Maintainting CIDB: Let, m be this struct (entry), E be the set 
of all edges. DB = {m1,m2,m3,...,mn}, 1 <= n <= |E|. 2 cases for
an entry: 
a. after creating its own measurement, sampling own and
other cars' speeds on its road. after t time threshold, its own
measurement gets outdated in the DB. a car will prioritize its
own entry over fresher ones unless it is at least t older. makes
it kinda secure.
b. after obtaining measurements thru congestion responses it 
decides what route to choose

3) Least congested route selection: 
    a. reach the end of the road
    b. calculate its interesting roads
    c. send congestion request asking for these roads
    d. merge both in CIDB
    e. routing decision:
        i. compute trip time for each of k candidate routes
            a. edge weight: calculate edge divided by avg speed
            b. route weight: calculate sum of all edge weights
                in the route
            c. find the minimum route weight out of all candidates
        ii. choose one of the lowest

*/
#ifndef TraCIDemo11p_H
#define TraCIDemo11p_H
#include <string>
#include <stdint.h>
#include <map>
#include <list>
#include <vector>
#include <math.h>
#include "veins/modules/application/ieee80211p/BaseWaveApplLayer.h"


class Uninfected : public BaseWaveApplLayer {
    public:
        virtual void initialize(int stage);
    protected:
        struct CongestionInfo {
            int creatorID;
            std::string edgeID;
            double avgSpeed;
            simtime_t timestamp;
            std::string toString() {
                return "creatorID=" + std::to_string(creatorID) + ",edgeID=" + edgeID + ",avgSpeed=" + std::to_string(avgSpeed) + ",timestamp=" + timestamp.str();
            }
        };
        struct CongestionInfo cInfo;
        std::map<std::string, struct CongestionInfo> cidb;     // carID, cInfo struct
        // basically insert your cidb here
        std::list<std::map<std::string, struct CongestionInfo>> candidateRoutes;
        double avgEdgeSpeed;
        simtime_t lastDroveAt;
        // for route following algo
        std::list<std::string> chosenRoute;
        bool changedRoute;

        bool sentMessage;
        int currentSubscribedServiceId;
    protected:
        virtual void onWSM(WaveShortMessage* wsm);
        virtual void onWSA(WaveServiceAdvertisment* wsa);
        virtual void onBSM(BasicSafetyMessage* bsm);

        virtual void handleSelfMsg(cMessage* msg);
        virtual void handlePositionUpdate(cObject* obj);
        virtual struct CongestionInfo stringToStruct(std::string str);
        virtual void updateDB(struct CongestionInfo cinfo);
        virtual void updateSelf();
        virtual void sendBeacon(struct CongestionInfo cInfo);
        virtual double calculateCIDBAvg(std::map<std::string, struct CongestionInfo> cidb);
        virtual std::string listStructToString(std::list<struct CongestionInfo> cidbResponse);
        virtual std::list<struct CongestionInfo> stringToListStruct(std::string cidbStr);
        virtual void sendCongestionRequest(std::string edgeIDs);
        virtual void sendCongestionResponse(std::list<struct CongestionInfo> cidbResponse);
        virtual std::string listToString(std::list<std::string> lanes);
        virtual std::list<std::string> stringToList(std::string edges);
        virtual void reroute();
        virtual std::string getElementByIndex(std::list<std::string> ls, int index);
        virtual std::list<std::string> getRouteListByCarID(std::list<std::string> ls, int carID);
        virtual std::pair<int,int> iterateRouteID(std::string routeID);
        virtual std::list<std::string> getAdjacentEdges();
};

#endif
